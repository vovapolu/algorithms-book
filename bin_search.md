#Бинарный поиск

Давайте начнем сразу с небольшого описания алгоритма. Суть бинарного поиска в том, что мы делим какое-то множество на две примерно равные части и, анализируя элемент по середине, отбрасываем либо первую, либо вторую половину. Далее продолжаем поиск рекурсивно в выбранной части множества. Уже можно догадаться, что алгоритм работает только тогда, когда можно выбрать этот "средний" элемент - тем самым необходима, например, упорядоченность рассматриваемого множества. Чтобы разобраться лучше, сейчас мы рассмотрим несколько задач, для которых бинарный поиск крайне эффективен, а иногда является единственным решением.    

###Поиск элемента в массиве

Пусть нам дан упорядоченный массив, который в процессе не будет изменяться. Пускай к нему приходит множество запросов на провеку того, что лежит ли данный элемент массиве или нет. Эту задачу мы будем решать с помощью бинарного поиска, который намного быстрее того же обычного линейного поиска, работающего в худшем случае за $$O(n)$$. 

Итак, суть все та же - выбираем средний элемент в массиве, сравниваем его с нужным элементом и отбрасываем или левую часть массива, или правую. Потом запускаем ту же процедуру над нужной половиной. В конце, мы придем к массиву длинной 1, и нам останется проверить только равенство этого одного элемента с данным. Приведем главную часть кода: 

```
#массив array отсортирован по возрастанию
def bin_search(array, elem):
	if len(array) < 1:                      # если массив пустой
	    return false                        # то никакого элемента там точно нет
		
	if len(array) == 1:                     # самый простой случай  
	                                        # массив состоит из одного элемента
		return array[0] == elem             # сравниваем единственный элемент с нужным
		
	m = len(array) // 2                     # тут идет выбор 
	                                        # "среднего" элемента в массиве
	if array[m] == elem:                    # если мы уже нашли элемент
	    return true                         # то почему бы сразу не понять это
	                            
	if array[m] < elem:                     # сравниваем "средний" элемент с данным 
	                                        # и понимаем какую половину массива следует нам отбросить
		return bin_search(array[m:], elem)  # если "средний" элемент меньше нужного 
		                                    # мы отбрасываем левую половину 
		                                    # так как все элементы в ней заведомо меньше 
	else:
		return bin_search(arra[:m], elem)   # аналогично для правой 
		                                    # где все элементы больше
```

В умных учебниках бинарный поиск известен под названием дихотомия, но, как я говорил ранее, мы не будем повторяться и перейдем к более практическому применению. 

