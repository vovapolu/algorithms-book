#Бинарный поиск

Давайте начнем сразу с небольшого описания алгоритма. Суть бинарного поиска в том, что мы делим какое-то множество на две примерно равные части и, анализируя элемент по середине, отбрасываем либо первую, либо вторую половину. Далее продолжаем поиск рекурсивно в выбранной части множества. Уже можно догадаться, что алгоритм работает только тогда, когда можно выбрать этот "средний" элемент - тем самым необходима, например, упорядоченность рассматриваемого множества. Чтобы разобраться лучше, сейчас мы рассмотрим несколько задач, для которых бинарный поиск крайне эффективен, а иногда является единственным решением.    

###Поиск элемента в массиве

Пусть нам дан упорядоченный массив, который в процессе не будет изменяться. Пускай к нему приходит множество запросов на проверку того, что лежит ли данный элемент массиве или нет. Эту задачу мы будем решать с помощью бинарного поиска, который намного быстрее того же обычного линейного поиска, работающего в худшем случае за $$O(n)$$. 

Итак, суть все та же - выбираем средний элемент в массиве, сравниваем его с нужным элементом и отбрасываем или левую часть массива, или правую. Потом запускаем ту же процедуру над нужной половиной. В конце, мы придем к массиву длинной 1, и нам останется проверить только равенство этого одного элемента с данным. Приведем главную часть кода: 

```
def bin_search(array, elem):                #массив array отсортирован по возрастанию
	if len(array) < 1:                      # если массив пустой
	    return False                        # то никакого элемента там точно нет
		
	if len(array) == 1:                     # самый простой случай  
	    return array[0] == elem             # массив состоит из одного элемента
	                                        # сравниваем этот элемент с нужным
		
	m = len(array) // 2                     # тут идет выбор "среднего"
	
	if array[m] == elem:                    # если мы уже нашли элемент
	    return True                         # то почему бы сразу не понять это
	                            
	if array[m] < elem:                     # сравниваем "средний" элемент с данным 
	    return bin_search(array[m:], elem)  # и понимаем какую половину массива следует нам отбросить
		                                    # если "средний" элемент меньше нужного 
		                                    # мы отбрасываем левую половину 
		                                    # так как все элементы в ней заведомо меньше 
	else:
		return bin_search(array[:m], elem)  # аналогично для правой 
		                                    # где все элементы больше
```

Эту рекурсию естественным образом можно переписать в цикл, который будет работать оптимальнее по времени и памяти. 

```
def bin_search(array, elem):    # массив опять отсортирован по возрастанию
    l = 0                       # теперь мы будем поддерживать отрезок индексов [l, r)
    r = len(array)              # в котором возможно будет нужный элемент
                                
                                # если элемент есть в массиве
                                # то он точно будет в этом отрезке
    
    if r == 0:                  # если отрезок с самого начала пустой
        return False            # то нашего элемента там точно нет
        
    while l <= r:               # сужаем наш отрезок, пока не останется один элемент
        m = (l + r) / 2         # как обычно выбираем "средний" элемент
        if array[m] <= elem:    # и сравниваем его с нужным
            l = m               # если средний элемент меньше, отбрасываем левую половину
                                # сдвигая левый конец отрезка l в середину m
        else:
            r = m               # аналогично, сдвигаем правый конце в середину
                                # отбрасывая правую половину
             
    return array[l] == elem     # и в конце проверяем содержит ли наш отрезок нужный элемент
```

Теперь исследуем скорость работы данного алгоритма. Допустим мы запускаем поиск на массиве длины $$n$$. Как уже говорилось ранее, каждая итерация бинарного поиска отбрасывает половину рассматриваемого массива, то есть после первого шага длина массива, в котором осуществляется поиск, будет равной $$n/2$$, после второго - $$n/2^2$$ ... после k-ого шага - $$n/2^k$$ (*Мы используем целочисленное деление, которое отбрасывает остаток. Эта небольшая погрешностью не повлияет на конечную оценку. К тому же, все это можно доказать строже, но я стремлюсь не к фундаментальным доказательствам и формальным определениям, а к описанию основных вещей наиболее понятным способом.)* В конце наш алгоритм должен сойтись к одному значению, если это произошло на итерации $$k$$, то $$n/2^k = 1$$ и $$n = 2^k$$, и становится ясно, что $$k = log_2(n)$$. *(Далее я буду обозначать $$log_2$$ просто как $$log$$)*. В итоге сложность алгоритма будет $$O(log(n))$$, учитывая целочисленное деление и количество операция в одном шаге. 


###Поиск значения функции на отрезке

Перейдем теперь к следующей задаче, в которой бинарный поиск по-настоящему незаменим. Рассмотрим монотонную функцию (для простоты она будет возрастать) на каком-нибудь отрезке, и требуется опять искать на этом отрезке определенные значения. 

Сразу же можно представить, что у нас есть бесконечный отсортированный массив, в котором индексы - это точки на отрезке, а содержимое массива - значения функции, только этот массив задан не явно, а посредством формулы. После этого наблюдения это задачу легко свести к бинарному поиску, но с одним замечанием. 
